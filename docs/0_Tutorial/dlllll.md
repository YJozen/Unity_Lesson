

---

# 3.C#コードとC++エンジンの通信について

## a. **エディタ実行時の通信**

Unityエディタ内でゲームを実行している場合、C#コードとC++エンジンの通信は、**C#ランタイム（Monoまたは.NET）**とUnityエンジンのC++コードを介して行われます。  
具体的には、C++エンジンは、C#で書かれたスクリプトに対してAPIを提供し、C#スクリプトはそのAPIを通じてエンジンの機能を利用します。

- **C#コードからC++エンジンへの通信**：
  C#コードがエンジンの機能を利用するために、C#メソッドをC++エンジンに渡し、その処理結果をC#に戻す形で通信が行われます。この過程は、**JIT（Just-In-Time）コンパイル**されたC#コードを通じて行われます。つまり、C#コードは実行時に機械語に変換され、これによりC++エンジンとの通信が効率的に行われます。

- **C++エンジン側のコード**：
  UnityのC++エンジンは、事前にコンパイルされて**ネイティブ機械語**として動作します。エディタ実行時には、C#コードはJITコンパイルされて機械語に変換される一方で、C++エンジン側はすでにコンパイルされたネイティブコードがそのまま実行されます。


### b. **ビルド時の動作（IL2CPP使用時）**

ビルド時、特にIL2CPP（Intermediate Language To C++）を使用する場合、C#コードはまず中間言語（IL）に変換され、その後IL2CPPによってC++のネイティブコードに変換されます。この際、**C#ランタイム**（Monoや.NET）は使用されず、C#コードは最終的にC++コードに変換され、C++コードがネイティブにコンパイルされて実行されます。

- **IL2CPPによるC++生成**：
  IL2CPPでは、C#コードがC++に変換され、その後ネイティブコードとしてコンパイルされます。これにより、最終的には**C++コードが直接実行される**ことになります。エディタ実行時のようなC#ランタイムは不要であり、**C#とC++間の通信方法が異なります**。通信は、C++コード内で直接実行される形になります。



<br>

<br>

---

<br>

<br>



# 4. **C#コードとC++エンジンの通信について**








## a. **エディタ実行時**

**P/Invoke**（**Platform Invocation Services**）は、.NET（C#）アプリケーションからネイティブコード（主にCやC++で書かれたコード）を呼び出すための仕組みです。簡単に言うと、C#からC++のようなネイティブライブラリの関数を呼び出せる機能です。

### 具体的な役割
C#などのマネージコードは、通常、.NETランタイム（Monoや.NET Coreなど）上で実行されますが、時にはネイティブコード（例えばCやC++で書かれたDLLや.soファイル）と連携したい場合があります。P/Invokeを使用することで、C#コードからこれらのネイティブコードを簡単に呼び出すことができます。

### 基本的な使い方
P/Invokeを使うためには、C#側でネイティブライブラリに含まれる関数を宣言し、その関数を呼び出すことができます。この宣言は、C#コードの中で、CやC++の関数のシグネチャ（名前、引数、戻り値の型など）と一致する形で行います。

### 例

以下は、C#からC++で書かれたネイティブライブラリ（`NativeLibrary.dll`）の関数を呼び出すサンプルコードです。

#### 1. C++側のコード（`NativeLibrary.dll`）
```cpp
// C++で作成するコード（NativeLibrary.cpp）
#include <iostream>

extern "C" __declspec(dllexport) void SomeNativeFunction() {
    std::cout << "Native function called!" << std::endl;
}
```
C++のコードでは、`SomeNativeFunction` をエクスポートすることで、外部から呼び出せるようにしています。

#### 2. C#側のコード
```csharp
using System;
using System.Runtime.InteropServices;

class NativeMethods
{
    // C++の関数をP/Invokeで呼び出す宣言
    [DllImport("NativeLibrary.dll")]
    public static extern void SomeNativeFunction();
}

public class Example
{
    void Start()
    {
        // C#からC++の関数を呼び出す
        NativeMethods.SomeNativeFunction();
    }
}
```

- **[DllImport]**：C#で使用される属性で、指定されたネイティブライブラリをインポートします。ここでは `NativeLibrary.dll` を指定しています。
- **extern**：C#コードでは実際の関数本体が存在しないことを意味します（外部で定義された関数を呼び出す）。
- **関数の宣言**：C#側で呼び出したいC++関数の名前とシグネチャを一致させます。

#### 3. 実行時
- C#コードが実行されると、`NativeLibrary.dll` が実行時にメモリに読み込まれ、その中の `SomeNativeFunction` が呼び出されます。
- ネイティブコード（C++）が実行され、その結果がC#に返ります。

### 特徴
- **クロスプラットフォーム**：P/Invokeは、Windows、Linux、macOSなどの異なるプラットフォームで動作するネイティブライブラリを呼び出す際に役立ちます。例えば、Windows用の`.dll`、Linux用の`.so`、macOS用の`.dylib`などです。
- **簡単に外部ライブラリを使用できる**：C#などのマネージコードから、CやC++などで書かれたパフォーマンス重視のコードを呼び出して使用できます。
- **型のマッピング**：P/Invokeを使用する際、C#のデータ型とC++のデータ型を正しくマッピングする必要があります。例えば、`int` 型がC#とC++で異なる場合がありますので、型の一致に注意が必要です。

### メリット
- **高性能なネイティブライブラリの利用**：C#だけで書かれたコードでは処理が重すぎる場合、C++で書かれた最適化されたネイティブライブラリを利用できます。
- **既存のC/C++ライブラリの活用**：C#で新たにライブラリを書く代わりに、既存のC/C++ライブラリを活用することができます。

### 注意点
- **管理外メモリの取り扱い**：ネイティブコードとのインターフェースでは、メモリ管理が重要です。C#側のガベージコレクションとは異なり、C++側では手動でメモリを管理するため、メモリリークに注意が必要です。
- **プラットフォーム依存**：P/Invokeで呼び出すネイティブライブラリは、プラットフォームごとに異なるバイナリを用意する必要があることがあります。

---

### まとめ
P/Invokeは、C#コードからC/C++で書かれたネイティブライブラリを呼び出すための仕組みで、主に外部のパフォーマンス重視の機能を利用する際に使われます。この仕組みを活用することで、C#だけでは実現しづらい低レベルの操作や最適化された機能を利用できます。




<br>

<br>

---

<br>

<br>




## b. **ビルド（エクスポート）時**

- **C++/CLI** は、ビルド後（IL2CPP使用時）に特に有効です。C#とC++間でシームレスな相互運用を実現するため、C++の関数をC#から直接利用したい場合に使用されます。これは主にビルド時の通信方法として関連しています。


- IL2CPPを使用した場合の動作を解説しますが、ビルド時にC#コードがどのようにC++に変換され、C++コードがネイティブに実行されるかについて説明します。
- **C++/CLI**の使用例をここで説明します。C++/CLIを使うことで、C#とC++がシームレスに統合される方法を示します。C++/CLIは、C#コードからC++コードを直接呼び出すためのブリッジとして機能します。

  #### サンプルコード（C++/CLI）
  ```cpp
  // C++/CLIラッパー
  public ref class ManagedWrapper
  {
  public:
      void CallNativeFunction()
      {
          NativeFunction(); // C++の関数を呼び出す
      }
  };
  ```

  ```csharp
  // C#コード
  ManagedWrapper^ wrapper = gcnew ManagedWrapper();
  wrapper->CallNativeFunction();
  ```

---



<br>

<br>

---

<br>

<br>



[DLL](DLL.md)



<br>

<br>

---

<br>

<br>


全体的な資料の流れとして

# 1.UnityでのC++の役割

# 2.コードについて
## a.エディタ実行時
## b.ビルド（エクスポート）時

# 3.C#コードとC++エンジンの通信について
## a.エディタ実行時
 **P/Invoke

## b.ビルド（エクスポート）時
C++/CLI 
としていますが、
 **P/Invoke
