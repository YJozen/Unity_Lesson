# 画面外インジケーターの実装

<br>

---

<br>

UI設定について、以下のような設定を想定しています：

1. **Canvasの作成**  
   UI要素は`Canvas`上に配置されている必要があります。新しい`Canvas`をシーンに作成し、`Canvas Scaler`コンポーネントの`UI Scale Mode`を`Scale with Screen Size`に設定することで、解像度に応じたサイズ調整が可能です。

2. **インジケーターUI要素**  
   画面端に表示される矢印や方向を示すアイコンをUI要素として配置します。インジケーターとして使うためのオブジェクトは、`Canvas`の子オブジェクトとして作成し、`RectTransform`を使用して配置を設定します。

3. **矢印アイコンの設定**  
   `Image`コンポーネントを使用して矢印や目標地点の方向を示すアイコン画像を割り当てます。このアイコンは、画面端に配置され、方向に応じて回転するように設定されます。

4. **RectTransformの設定**  
   `RectTransform`を使って、インジケーターが画面外に出た場合の位置を動的に調整するため、スクリプト内で`indicatorUIElement`として参照する必要があります。この要素の位置はスクリプト内で動的に設定されるため、インスペクター上の初期位置は適切に設定します。

5. **インスペクターの設定**  
   `ScreenEdgeIndicator`スクリプトを目的の`GameObject`にアタッチし、以下の設定を行います：
   - **Target**: インジケーターが追従する`Transform`オブジェクト（例えば、プレイヤーが目指す地点）。
   - **Indicator UI Element**: インジケーターとして使用する`RectTransform`を持つUI要素（矢印アイコンなど）。
   - **Main Camera**: メインカメラを指定（通常`Camera.main`）。
   - **Edge Padding**: インジケーターの表示位置が画面端からどれだけ離れるかの余白を設定。

---

このUI設定により、目標地点が画面内であれば非表示に、画面外に出た場合はインジケーターとして方向を示すUIが表示され、視覚的に分かりやすく目標地点を確認できるようになります。

<br>

---

<br>

# 1. **通常のカメラを使った画面外インジケーターの実装方法**

まず、Unityの通常のカメラで目標地点が画面外にある場合、その方向を示すインジケーターを表示する方法を見ていきます。

## ステップ 1: 目標地点が画面内か画面外かの判定
- `Camera.main.WorldToViewportPoint(targetPosition)` を使って目標地点のビューポート座標を取得します。
- ビューポート座標の`x`と`y`が0から1の範囲内であれば画面内、範囲外であれば画面外にあります。

```csharp
Vector3 viewportPoint = Camera.main.WorldToViewportPoint(targetPosition);
bool isTargetVisible = viewportPoint.z > 0 && viewportPoint.x >= 0 && viewportPoint.x <= 1 && viewportPoint.y >= 0 && viewportPoint.y <= 1;
```

## ステップ 2: インジケーターの位置計算
- 画面外にある場合、インジケーターはスクリーンの端に配置する必要があります。
- `Mathf.Clamp` を使って、ビューポートの座標を端の範囲内に固定します。

```csharp
Vector3 clampedViewportPoint = new Vector3(
    Mathf.Clamp(viewportPoint.x, 0.05f, 0.95f),
    Mathf.Clamp(viewportPoint.y, 0.05f, 0.95f),
    viewportPoint.z
);
Vector3 screenPosition = Camera.main.ViewportToScreenPoint(clampedViewportPoint);
indicatorUIElement.position = screenPosition;
```

## ステップ 3: 方向の回転を設定
- インジケーターが向くべき方向を設定するために、目標地点からカメラ位置への方向ベクトルを使います。
- `Mathf.Atan2` 関数を使用して、インジケーターの回転角度を求めます。

```csharp
Vector3 direction = targetPosition - Camera.main.transform.position;
float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
indicatorUIElement.rotation = Quaternion.Euler(0, 0, angle);
```

---

# 2. **Cinemachineを使った画面外インジケーターの実装方法**

Cinemachineを使用する場合も、基本の流れは同じですが、Cinemachine特有の動的なカメラ制御を考慮する必要があります。

#### ステップ 1: カメラ参照と視点の動的なチェック
- Cinemachineを使うときは、`CinemachineBrain`や`CinemachineVirtualCamera`のカメラを参照しますが、実際のカメラのビュー情報は`Camera.main`を使って確認できます。
- 画面外チェックは通常のカメラと同じく`WorldToViewportPoint`を使って行います。

```csharp
Vector3 viewportPoint = Camera.main.WorldToViewportPoint(targetPosition);
bool isTargetVisible = viewportPoint.z > 0 && viewportPoint.x >= 0 && viewportPoint.x <= 1 && viewportPoint.y >= 0 && viewportPoint.y <= 1;
```

#### ステップ 2: Cinemachineの遅延やズームに対応
- Cinemachineのカメラはズームや遅延で動的に変化することが多いため、インジケーターUIの大きさや位置も随時更新していきます。
- カメラが動いた際、`indicatorUIElement`のサイズや位置も自動でスムーズに調整されるように`Lerp`などを用いて遅延をかけると効果的です。

```csharp
Vector3 targetScreenPosition = Camera.main.ViewportToScreenPoint(clampedViewportPoint);
indicatorUIElement.position = Vector3.Lerp(indicatorUIElement.position, targetScreenPosition, Time.deltaTime * smoothSpeed);
```

#### ステップ 3: Cinemachineカメラ切り替え時のインジケーター表示
- カメラ切り替えが頻繁に発生する場合は、インジケーターのフェードイン・アウトを加えてわかりやすくすると、ユーザーが目標を見失わないようにできます。

---

### まとめ

どちらの実装も基本的には同じで、ビューポート座標を使用して目標が画面外にあるかどうかを判定し、方向インジケーターをスクリーン端に表示します。Cinemachineの場合は、動的なカメラ移動に対応するために、インジケーターの表示を少し遅延させたり、フェード効果を追加することでより直感的な体験を提供できます。









こちらが、Unityで目標地点が画面外に出た場合にインジケーターを表示するスクリプトです。このスクリプトを`GameObject`にアタッチし、目標地点がカメラの視界外にある場合は画面端にインジケーターを表示して方向を示します。また、`Cinemachine`にも対応しています。

```csharp
using UnityEngine;
using UnityEngine.UI;

public class ScreenEdgeIndicator : MonoBehaviour
{
    public Transform target; // 目標地点のTransform
    public RectTransform indicatorUIElement; // インジケーターUIのRectTransform
    public Camera mainCamera; // メインカメラ (Cinemachine使用時も参照)
    public float edgePadding = 50.0f; // 画面端からのインジケーターの余白

    void Update()
    {
        // ターゲットのビューポート座標を取得
        Vector3 viewportPos = mainCamera.WorldToViewportPoint(target.position);

        // 目標地点が画面内にあるかどうかを判定
        bool isTargetVisible = viewportPos.z > 0 && viewportPos.x >= 0 && viewportPos.x <= 1 && viewportPos.y >= 0 && viewportPos.y <= 1;

        // インジケーターの表示・非表示を切り替え
        indicatorUIElement.gameObject.SetActive(!isTargetVisible);

        if (!isTargetVisible)
        {
            // 画面外にある場合、ビューポート座標をスクリーン端に固定
            Vector3 clampedViewportPos = viewportPos;
            clampedViewportPos.x = Mathf.Clamp(clampedViewportPos.x, 0.05f, 0.95f);
            clampedViewportPos.y = Mathf.Clamp(clampedViewportPos.y, 0.05f, 0.95f);

            // インジケーターの位置をスクリーン座標に変換
            Vector3 screenPos = mainCamera.ViewportToScreenPoint(clampedViewportPos);
            screenPos.x = Mathf.Clamp(screenPos.x, edgePadding, Screen.width - edgePadding);
            screenPos.y = Mathf.Clamp(screenPos.y, edgePadding, Screen.height - edgePadding);
            indicatorUIElement.position = screenPos;

            // インジケーターの回転を目標地点の方向に合わせる
            Vector3 direction = target.position - mainCamera.transform.position;
            float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
            indicatorUIElement.rotation = Quaternion.Euler(0, 0, angle);
        }
    }
}
```

---

### スクリプトの使用方法

1. **目標地点**: インスペクターの`target`に追跡する目標地点（例: 敵や目的地）を設定します。
2. **インジケーターUI**: インスペクターの`indicatorUIElement`には、画面端に表示するインジケーター用の`UI`オブジェクト（`RectTransform`付きのUI要素）を指定します。たとえば、矢印のアイコンなどを配置できます。
3. **メインカメラ**: `mainCamera`には、通常は`Camera.main`（シーン内のメインカメラ）を使用しますが、Cinemachineを使用している場合も、同様にメインカメラを参照します。
4. **画面端の余白**: `edgePadding`で、インジケーターが画面端からどれだけ離れるかを調整できます。

### ポイント

- **Cinemachine**: `mainCamera`がCinemachineのカメラを使っている場合も、通常のカメラと同じくビューポート座標を取得して、インジケーターの表示位置を調整します。
- **インジケーターの回転**: 目標地点の方向に応じてインジケーターが回転し、どの方向に向かえばよいかが分かりやすくなります。